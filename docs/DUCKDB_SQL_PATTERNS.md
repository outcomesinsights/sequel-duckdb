# DuckDB SQL Syntax Patterns Documentation

This document provides comprehensive documentation of the specific SQL syntax patterns generated by the sequel-duckdb adapter. Understanding these patterns is essential for developers using the adapter to write efficient queries and troubleshoot issues.

## Overview

The sequel-duckdb adapter generates SQL that is optimized for DuckDB's analytical capabilities while maintaining compatibility with Sequel's established conventions. The adapter makes specific choices about SQL syntax to ensure optimal performance and compatibility with DuckDB's features.

## Core SQL Generation Patterns

### 1. LIKE Clause Generation

The adapter generates clean LIKE clauses without unnecessary ESCAPE clauses, following DuckDB's simplified syntax requirements.

#### Standard LIKE Patterns
```ruby
# Sequel Code
dataset.where(Sequel.like(:name, "%John%"))

# Generated SQL
SELECT * FROM users WHERE (name LIKE '%John%')
```

#### NOT LIKE Patterns
```ruby
# Sequel Code
dataset.exclude(Sequel.like(:name, "%John%"))

# Generated SQL
SELECT * FROM users WHERE (name NOT LIKE '%John%')
```

#### Pattern Variations
```ruby
# Prefix matching
dataset.where(Sequel.like(:name, "John%"))
# SQL: SELECT * FROM users WHERE (name LIKE 'John%')

# Suffix matching
dataset.where(Sequel.like(:name, "%Doe"))
# SQL: SELECT * FROM users WHERE (name LIKE '%Doe')

# Contains matching
dataset.where(Sequel.like(:name, "%John%"))
# SQL: SELECT * FROM users WHERE (name LIKE '%John%')
```

**Design Decision**: DuckDB handles pattern matching efficiently without explicit ESCAPE clauses, so the adapter omits them for cleaner SQL generation.

### 2. Case-Insensitive LIKE (ILIKE) Patterns

Since DuckDB doesn't have native ILIKE support, the adapter converts ILIKE operations to UPPER() LIKE UPPER() patterns with proper parentheses.

#### ILIKE Conversion
```ruby
# Sequel Code
dataset.where(Sequel.ilike(:name, "%john%"))

# Generated SQL
SELECT * FROM users WHERE (UPPER(name) LIKE UPPER('%john%'))
```

#### NOT ILIKE Conversion
```ruby
# Sequel Code
dataset.exclude(Sequel.ilike(:name, "%john%"))

# Generated SQL
SELECT * FROM users WHERE (UPPER(name) NOT LIKE UPPER('%john%'))
```

**Design Decision**: The UPPER() workaround ensures case-insensitive matching works correctly in DuckDB while maintaining Sequel's ILIKE interface.

### 3. Regular Expression Patterns

The adapter uses DuckDB's `regexp_matches()` function for reliable regex operations, with proper parentheses for expression grouping.

#### Basic Regex Matching
```ruby
# Sequel Code
dataset.where(name: /^John/)

# Generated SQL
SELECT * FROM users WHERE (regexp_matches(name, '^John'))
```

#### Case-Insensitive Regex
```ruby
# Sequel Code
dataset.where(name: /john/i)

# Generated SQL
SELECT * FROM users WHERE (regexp_matches(name, 'john', 'i'))
```

#### Complex Regex Patterns
```ruby
# Sequel Code
dataset.where(name: /^John.*Doe$/)

# Generated SQL
SELECT * FROM users WHERE (regexp_matches(name, '^John.*Doe$'))
```

**Design Decision**: Using `regexp_matches()` instead of the `~` operator provides more reliable regex functionality and better error handling in DuckDB.

### 4. Qualified Column References

The adapter uses standard SQL dot notation for qualified column references, ensuring compatibility with SQL standards and DuckDB's expectations.

#### Table.Column Format
```ruby
# Sequel Code
dataset.join(:profiles, user_id: :id)

# Generated SQL
SELECT * FROM users INNER JOIN profiles ON (profiles.user_id = users.id)
```

#### Subquery Column References
```ruby
# Sequel Code
subquery = db[:orders].select(:count).where(user_id: :users__id)
dataset.select(:name, subquery.as(:order_count))

# Generated SQL
SELECT name, (SELECT count FROM orders WHERE (user_id = users.id)) AS order_count FROM users
```

**Design Decision**: Standard dot notation is universally supported and provides clear, readable SQL that works optimally with DuckDB's query planner.

### 5. JOIN Operations

The adapter supports all standard JOIN types with proper syntax generation for DuckDB.

#### INNER JOIN
```ruby
# Sequel Code
dataset.join(:profiles, user_id: :id)

# Generated SQL
SELECT * FROM users INNER JOIN profiles ON (profiles.user_id = users.id)
```

#### LEFT JOIN
```ruby
# Sequel Code
dataset.left_join(:profiles, user_id: :id)

# Generated SQL
SELECT * FROM users LEFT JOIN profiles ON (profiles.user_id = users.id)
```

#### JOIN USING Clause
```ruby
# Sequel Code (using internal JOIN USING clause)
join_clause = Sequel::SQL::JoinUsingClause.new([:user_id], :inner, :profiles)
dataset.clone(join: [join_clause])

# Generated SQL
SELECT * FROM users INNER JOIN profiles USING (user_id)
```

#### Multiple Column USING
```ruby
# Generated SQL for multiple columns
SELECT * FROM users INNER JOIN profiles USING (user_id, company_id)
```

**Design Decision**: JOIN USING provides more concise syntax for equi-joins and is well-supported by DuckDB's optimizer.

### 6. Common Table Expressions (CTEs)

The adapter automatically detects recursive CTEs and generates appropriate WITH RECURSIVE syntax.

#### Regular CTE
```ruby
# Sequel Code
cte = db[:users].select(:id, :name).where(active: true)
dataset.with(:active_users, cte).from(:active_users)

# Generated SQL
WITH active_users AS (SELECT id, name FROM users WHERE (active IS TRUE)) SELECT * FROM active_users
```

#### Recursive CTE (Auto-detected)
```ruby
# Sequel Code
base_case = db.select(Sequel.as(1, :n))
recursive_case = db[:t].select(Sequel.lit("n + 1")).where { n < 10 }
combined = base_case.union(recursive_case, all: true)
dataset.with(:t, combined).from(:t)

# Generated SQL
WITH RECURSIVE t AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM t WHERE (n < 10)) SELECT * FROM t
```

**Design Decision**: Auto-detection of recursive CTEs based on self-references simplifies usage while ensuring correct SQL generation for DuckDB.

### 7. Data Type Literals

The adapter formats literals according to DuckDB's expectations for optimal type handling.

#### String Literals
```ruby
# Sequel Code
dataset.where(name: "John's Name")

# Generated SQL
SELECT * FROM users WHERE (name = 'John''s Name')
```

#### Date/Time Literals
```ruby
# Date literal
dataset.where(birth_date: Date.new(2023, 5, 15))
# SQL: SELECT * FROM users WHERE (birth_date = '2023-05-15')

# DateTime literal
dataset.where(created_at: Time.new(2023, 5, 15, 14, 30, 0))
# SQL: SELECT * FROM users WHERE (created_at = '2023-05-15 14:30:00')

# Time-only literal
dataset.where(start_time: Time.local(1970, 1, 1, 9, 30, 0))
# SQL: SELECT * FROM users WHERE (start_time = '09:30:00')
```

#### Boolean Literals
```ruby
# Sequel Code
dataset.where(active: true)

# Generated SQL
SELECT * FROM users WHERE (active IS TRUE)
```

#### NULL Literals
```ruby
# Sequel Code
dataset.where(deleted_at: nil)

# Generated SQL
SELECT * FROM users WHERE (deleted_at IS NULL)
```

**Design Decision**: Using IS TRUE/IS FALSE and IS NULL provides explicit boolean and null comparisons that work reliably in DuckDB.

### 8. Complex Expressions and Parentheses

The adapter ensures proper parentheses around complex expressions for correct operator precedence and readability.

#### Expression Grouping
```ruby
# All complex expressions are wrapped in parentheses
# LIKE: (name LIKE '%John%')
# ILIKE: (UPPER(name) LIKE UPPER('%john%'))
# Regex: (regexp_matches(name, '^John'))
# Boolean: (active IS TRUE)
# Comparisons: (age > 25)
```

**Design Decision**: Consistent parentheses ensure correct operator precedence and make generated SQL more readable and maintainable.

### 9. Window Functions

The adapter supports DuckDB's comprehensive window function capabilities.

#### Basic Window Function
```ruby
# Sequel Code
dataset.select(:name, Sequel.function(:row_number).over(order: :name))

# Generated SQL
SELECT name, row_number() OVER (ORDER BY name) FROM users
```

#### Partitioned Window Function
```ruby
# Sequel Code
dataset.select(
  :product_id,
  :amount,
  Sequel.function(:rank).over(partition: :category, order: Sequel.desc(:amount)).as(:rank)
)

# Generated SQL
SELECT product_id, amount, rank() OVER (PARTITION BY category ORDER BY amount DESC) AS rank FROM sales
```

**Design Decision**: DuckDB's window functions are highly optimized for analytical queries, so the adapter exposes their full capabilities.

### 10. Aggregate Functions

The adapter generates standard aggregate function syntax optimized for DuckDB's columnar storage.

#### Standard Aggregates
```ruby
# Sequel Code
dataset.select(
  Sequel.function(:count, :*).as(:total_count),
  Sequel.function(:avg, :age).as(:avg_age),
  Sequel.function(:max, :age).as(:max_age)
)

# Generated SQL
SELECT count(*) AS total_count, avg(age) AS avg_age, max(age) AS max_age FROM users
```

**Design Decision**: Standard aggregate syntax leverages DuckDB's columnar optimizations for analytical workloads.

## Performance Optimizations

### 1. Columnar Projection
The adapter optimizes SELECT statements for DuckDB's columnar storage by generating efficient column projections.

### 2. Parallel Execution Hints
For complex queries, the adapter can include hints for DuckDB's parallel execution engine.

### 3. Bulk Operations
The adapter uses DuckDB's efficient bulk loading capabilities for multi-insert operations.

## Error Handling Patterns

The adapter maps DuckDB errors to appropriate Sequel exception types:

- Connection errors → `Sequel::DatabaseConnectionError`
- Constraint violations → `Sequel::ConstraintViolation` (and subtypes)
- SQL syntax errors → `Sequel::DatabaseError`
- Table/column not found → `Sequel::DatabaseError`

## Best Practices for Developers

### 1. Use Appropriate Data Types
```ruby
# Prefer specific types for better performance
create_table :events do
  primary_key :id
  DateTime :timestamp    # Use DateTime for timestamps
  Time :time_only       # Use Time for time-only values
  String :category      # Use String for text
  Integer :count        # Use Integer for whole numbers
  Float :amount         # Use Float for decimals
end
```

### 2. Leverage DuckDB's Analytical Features
```ruby
# Use window functions for analytical queries
sales_with_rank = db[:sales]
  .select(
    :product_id,
    :amount,
    Sequel.function(:rank).over(partition: :category, order: Sequel.desc(:amount))
  )

# Use CTEs for complex analytical queries
monthly_sales = db[:sales]
  .select(:month, Sequel.function(:sum, :amount).as(:total))
  .group(:month)

result = db.with(:monthly, monthly_sales)
  .from(:monthly)
  .where { total > 10000 }
```

### 3. Optimize for Columnar Storage
```ruby
# Select only needed columns for better performance
db[:large_table].select(:id, :name, :amount).where(active: true)

# Use appropriate aggregations
db[:sales].group(:category).select(
  :category,
  Sequel.function(:sum, :amount),
  Sequel.function(:count, :*)
)
```

## Troubleshooting Common Issues

### 1. LIKE Clause Issues
If LIKE clauses aren't working as expected, ensure you're not expecting ESCAPE clause behavior:
```ruby
# Correct - no ESCAPE needed
dataset.where(Sequel.like(:name, "%John%"))
```

### 2. Case-Insensitive Matching
Use ILIKE for case-insensitive matching:
```ruby
# Case-insensitive search
dataset.where(Sequel.ilike(:name, "%john%"))
```

### 3. Regular Expression Matching
Use Ruby regex syntax for pattern matching:
```ruby
# Regex matching
dataset.where(name: /^John.*Doe$/)
```

### 4. Qualified Column References
Use standard Sequel syntax for qualified columns:
```ruby
# Correct qualified reference
dataset.join(:profiles, user_id: :id)
# Generates: profiles.user_id = users.id
```

This documentation provides a comprehensive reference for understanding and working with the SQL patterns generated by the sequel-duckdb adapter. The patterns are designed to leverage DuckDB's strengths while maintaining compatibility with Sequel's conventions.